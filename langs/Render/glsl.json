[
  {
    "name": "Basic shaders",
    "info": "The most simple fragment and vertex shaders you can have",
    "content": "//basic shaders\n\n\n//Vertex shader\n//Vertex shader gets called for every vertex\n#version 330 core //tell OpenGl to use Version 330\nlayout(location = 0) in vec4 position; //our vector4D called position is pulled from the frame buffer at memory offset 0\n\n//Entry point\nvoid main()\n{\n    gl_Position = position; //gl_position is the output position of our vertex\n};\n\n//Fragment shader\n//This shader gets called for every pixel of the specified buffer\n//multiple vao's == multiple fragment shaders\n\nlayout(location = 0) out vec4 color; //same as above but an output\nvec4 u_color = vec4(0.1, 0.1, 0.1,1.0); //our input color is in the format RGBA\n\nvoid main()\n{\n    color = u_color; //we asign the color of the pixel to the input \n};"
  },
  {
    "name": "Custom input variables",
    "info": "How you can supply input variables from cpp",
    "content": "//Fragment shader\n//This shader gets called for every pixel of the specified buffer\n//multiple vao's == multiple fragment shaders\n\nlayout(location = 0) out vec4 color; //same as above but an output\n//we pass uniform values from c++ based on the program id and the variable name\nuniform vec4 u_color; //our input color specified in c++\n\nvoid main()\n{\n    color = u_color; //we asign the color of the pixel to the input \n};"
  },
  {
    "name": "Uniform variables",
    "info": "More information about uniform variables",
    "content":  "//Read only uniform variables\n\n<opengl> <cpp datatype> <description>\nbool int Conditional type, taking on values of true or false.\nint int Signed integer.\nfloat float Single floating-point scalar.\nvec2 float [2] Two component floating-point vector.\nvect3 float [3] Three component floating-point vector.\nvec4 float [4] Four component floating-point vector.\nbvec2 int [2] Two component Boolean vector.\nbvec3 int [3] Three component Boolean vector.\nbvec4 int [4] Four component Boolean vector.\nivec2 int [2] Two component signed integer vector.\nivec3 int [3] Three component signed integer vector.\nivec4 int [4] Four component signed integer vector.\nmat2 float [4] 2×2 floating-point matrix.\nmat3 float [9] 3×3 floating-point matrix.\nmat4 float [16] 4×4 floating-point matrix.\nsampler1D int Handle for accessing a 1D texture.\nsampler2D int Handle for accessing a 2D texture.\nsampler3D int Handle for accessing a 3D texture.\nsamplerCube int Handle for accessing a cubemap texture.\nsampler1DShadow int Handle for accessing a 1D depth texture with comparison.\nsampler2DShadow int Handle for accessing a 2D depth texture with comparison. \n\n//uniform declaration\nuniform vec4 light0color;\n\n//bind texture to uniforms\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, mytexturebaseID);\nlocation = glGetUniformLocationARB(program, ”baseTexture”);\nglUniform1iARB(location, 0); // Bind baseTexture to TU 0. \n\n//glsl datatype\nuniform sampler2D baseTexture; "
  },
  {
    "name": "Vertex attributes",
    "info": "Vertex only variables",
    "content": "//You have 2 types of vertex attributes\n//called defined and generic\n//defined attributes are normals, texture coordinates, per-vertex color materials ...\n//generic attributes are attributes defined by the developer bi-normals, particle properties and skinning information (bones)\n\n//for defined attributes you have implemented methods like glTexCoord2f and glVertex3f\n//generic attributes are passed via glVertexAttrib\n\n//Cpp code to set an attrib\nint slot = 9; //A random slot.\nglBindAttribLocationARB(program, slot, “fooAttribute”);\n//bind buffers and perform a drawcall\nglVertexAttrib3fARB(slot,2,3,1);\nglVertex3f(0,1,0);\nglNormal3f(1,0,0); \n\n//access attributes in glsl\nattribute vec3 fooAttribute; \n\n//possible attributes\n//float vec2 vec3 vec4 mat2 mat3 and mat4\n"
  },
  {
    "name": "Varying Variables",
    "info": "A way of passing variables from the vertex shader to the fragment shader",
    "content": "//Varying variables\n\n//example vertex shader code\nvarying vec2 myTexCood;\nvoid main()\n{\n // We compute the vertex position as the fixed function does.\n gl_Position = ftransform();\n // We fill our varying variable with the texture\n //coordinate related to the texture unit 0 (gl_MultiTexCoord0 refers to the TU0\n //interpolator).\n myTexCoord = vec(gl_MultiTexCoord0);\n }\n\n //fragment shader code\n\n varying vec2 myTexCoord;\nuniform sampler2D myTexture;\nvoid main()\n{\n //Use myTexCoord by any way, for example, to access a texture.\n gl_FragColor = texture2D(myTexture, myTexCoord);\n} "
  },
  {
    "name": "Statements and functions",
    "info": "Basic statements and functions",
    "content": "//If statement\n\nif (bool expression){\n    //logic\n}else if (bool expression2){\n    //logic if expression==false && expression2==true\n}\nelse{\n    //logic if all expressions are false\n}\n\n//for loop\nfor (initialization; bool expression; loop expression){\n    //loop body\n}\n\n//while and do while\nwhile (bool expression){ //body }\ndo { //body } while (bool expression)\n\n//functions\n\nvec4 cartoonify(in float intensity) {\n\n    vec4 color;\n    if (intensity > 0.98)\n        color = vec4(0.8,0.8,0.8,1.0);\n    else if (intensity > 0.5)\n        color = vec4(0.4,0.4,0.8,1.0);\n    else if (intensity > 0.25)\n        color = vec4(0.2,0.2,0.4,1.0);\n    else\n        color = vec4(0.1,0.1,0.1,1.0);        \n\n    return(color);\n}"
  },
  {
    "name": "Spaces and matrices",
    "info": "Know what spaces are and how to use matrices to get the desired output",
    "content": "//Note: No code is displayd here only Math needed for transformation\n\n//GLSL has 4 relevant spaces\n\n//local space: the space wherea model is created\n//world space : where we assemble our 3D scene\n//Camera space: the qpace where the camera is at the origin (looking down on the negative z axis)\n//clip space: this is the post projection space, where the view frustum is transformed into a cube, centered in the origin, and going from -1 to 1 in every axis.\n\n//to transform between spaces we use 3 4x4  matrices\n\nmat4 viewmodel = view * model;\nmat4 projViwModel = projection * view * model;\n\n//The matrix form for a general affine transformation, using homogeneous coordinates, is a matrix whose last row is [0 0 0 1]. The last column contains the translation, and the top 3×3 submatrix the rotations and scales.\n\n//Convert point P from local to camera space\nP' = view * model * P = viewModel * P\n\n//Transformation for not normalized vectors\nvec3 v; //vector in 3D space\nvec2 P1; //point in 3D space\nvec3 P2; // Same as P1 but another location\nmat4 M; //Transformation matrix\n//Original Vector\nv = P2 - P1\n//Vector transformation\nv' = M * v = M * (P2 - P1) = M * P2 - M * P = P2' - P1'\n\n//Normalized vectors (must be perpendicular to the tangent)\nvec3 T = P2 - P1; //Tangent vector\nvec3 T' = P2' - P1' = T * M; //Tangent' stays the same\n\nvec3 N; //Our normal vector\nvec3 N'; //Our transformed normal vector\nmat3 G; //our tranformation matrix used to keep the vector perpendicular to the tangent\n\n//T and T' are both perpendicular hence there dot product must be zero\n(M*T)*(G*N)=0\n//rewriten\nG = (M^T)^-1 <=>\nG = M"
  },
  {
    "name": "Basic Shader examples",
    "info": "How to render a cube and do per pixel coloring",
    "content": "//Vertex shader for a rotated cube\n#version 330\n \nlayout (std140) uniform Matrices {\n    mat4 pvm; // projection view model\n} ;\n \nin vec4 position; //position of the vertex\n \nout vec4 color; //This will be used inside the fragment shader\n \nvoid main()\n{\n    color = position;\n    gl_Position = pvm * position ; //Perform a rotation scale translation dependant on the input (camera location)\n}\n\n//Fragment shader\n#version 330\n \nin vec4 color; //Get the color of the vertex shader\n \nout vec4 outputF; //our final color\n \nvoid main()\n{\n    outputF = color;\n}"
  },
  {
    "name": "Simple lighting script",
    "info": "An example of how to use lighting in glsl",
    "content": "//Lighting example \n\n//Vertex Shader\nconst int NUM_LIGHTS = 3;\n\nuniform vec3 cameraPosition;\nuniform vec3 lightPosition[NUM_LIGHTS];\n\nvarying vec3 fragmentNormal;\nvarying vec3 cameraVector;\nvarying vec3 lightVector[NUM_LIGHTS];\n\nvoid\nmain()\n{\n    // set the normal for the fragment shader and\n    // the vector from the vertex to the camera\n    fragmentNormal = gl_Normal;\n    cameraVector = cameraPosition - gl_Vertex.xyz;\n\n    // set the vectors from the vertex to each light\n    for(int i = 0; i < NUM_LIGHTS; ++i)\n        lightVector[i] = lightPosition[i] - gl_Vertex.xyz;\n\n    // output the transformed vertex\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n}\n\n//Fragment Shader\n\nconst int NUM_LIGHTS = 3;\nconst vec3 AMBIENT = vec3(0.1, 0.1, 0.1);\nconst float MAX_DIST = 2.5;\nconst float MAX_DIST_SQUARED = MAX_DIST * MAX_DIST;\n\nuniform vec3 lightColor[NUM_LIGHTS];\n\nvarying vec3 fragmentNormal;\nvarying vec3 cameraVector;\nvarying vec3 lightVector[NUM_LIGHTS];\n\nvoid\nmain()\n{\n    // initialize diffuse/specular lighting\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n\n    // normalize the fragment normal and camera direction\n    vec3 normal = normalize(fragmentNormal);\n    vec3 cameraDir = normalize(cameraVector);\n\n    // loop through each light\n    for(int i = 0; i < NUM_LIGHTS; ++i) {\n        // calculate distance between 0.0 and 1.0\n        float dist = min(dot(lightVector[i], lightVector[i]), MAX_DIST_SQUARED) / MAX_DIST_SQUARED;\n        float distFactor = 1.0 - dist;\n\n        // diffuse\n        vec3 lightDir = normalize(lightVector[i]);\n        float diffuseDot = dot(normal, lightDir);\n        diffuse += lightColor[i] * clamp(diffuseDot, 0.0, 1.0) * distFactor;\n\n        // specular\n        vec3 halfAngle = normalize(cameraDir + lightDir);\n        vec3 specularColor = min(lightColor[i] + 0.5, 1.0);\n        float specularDot = dot(normal, halfAngle);\n        specular += specularColor * pow(clamp(specularDot, 0.0, 1.0), 16.0) * distFactor;\n    }\n\n    vec4 sample = vec4(1.0, 1.0, 1.0, 1.0);\n    gl_FragColor = vec4(clamp(sample.rgb * (diffuse + AMBIENT) + specular, 0.0, 1.0), sample.a);\n}"
  }
]