[
  {
    "name": "Singleton",
    "info": "Make only one instance of the object (is overused)",
    "content": "/*\nThe Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance.\nIt is named after the singleton set, which is defined to be a set containing one element. \nThis is useful when exactly one object is needed to coordinate actions across the system.\n*/\n\nclass StringSingleton\n {\n public:\n     // Some accessor functions for the class, itself\n     std::string GetString() const \n     {return mString;}\n     void SetString(const std::string &newStr)\n     {mString = newStr;}\n \n     // The magic function, which allows access to the class from anywhere\n     // To get the value of the instance of the class, call:\n     //     StringSingleton::Instance().GetString();\n     static StringSingleton &Instance()\n     {\n         // This line only runs once, thus creating the only instance in existence\n         static std::auto_ptr<StringSingleton> instance( new StringSingleton );\n         // dereferencing the variable here, saves the caller from having to use \n         // the arrow operator, and removes temptation to try and delete the \n         // returned instance.\n         return *instance; // always returns the same instance\n     }\n \n private: \n     // We need to make some given functions private to finish the definition of the singleton\n     StringSingleton(){} // default constructor available only to members or friends of this class\n \n     // Note that the next two functions are not given bodies, thus any attempt \n     // to call them implicitly will return as compiler errors. This prevents \n     // accidental copying of the only instance of the class.\n     StringSingleton(const StringSingleton &old); // disallow copy constructor\n     const StringSingleton &operator=(const StringSingleton &old); //disallow assignment operator\n \n     // Note that although this should be allowed, \n     // some compilers may not implement private destructors\n     // This prevents others from deleting our one single instance, which was otherwise created on the heap\n     ~StringSingleton(){} \n private: // private data for an instance of this class\n     std::string mString;\n };\n\n int main(){\n    StringSingleton::Instance(); //only way to get the singleton object\n }"
  },
  {
    "name": "Prototype",
    "info": "Prototype is used when a full clone is to expensive and costly",
    "content": "/*\nA prototype pattern is used in software development when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.\nThis pattern is used, for example, when the inherent cost of creating a new object in the standard way (e.g., using the new keyword) is prohibitively expensive for a given application.\n*/\n\n/** Implementation of Prototype Method **/\n#include <iostream>\n#include <unordered_map>\n#include <string>\n#include <memory>\nusing namespace std;\n\n/** Record is the base Prototype */\nclass Record\n{\npublic:\n    virtual ~Record() {}\n    virtual void print() = 0;\n    virtual unique_ptr<Record> clone() = 0;\n};\n\n/** CarRecord is a Concrete Prototype */\nclass CarRecord : public Record\n{\nprivate:\n    string m_carName;\n    int m_ID;\n\npublic:\n    CarRecord(string carName, int ID) : m_carName(carName), m_ID(ID)\n    {\n    }\n\n    void print() override\n    {\n        cout << \"Car Record\" << endl\n             << \"Name  : \"   << m_carName << endl\n             << \"Number: \"   << m_ID << endl << endl;\n    }\n\n    unique_ptr<Record> clone() override\n    {\n        return make_unique<CarRecord>(*this);\n    }\n};\n\n/** BikeRecord is the Concrete Prototype */\nclass BikeRecord : public Record\n{\nprivate:\n    string m_bikeName;\n    int m_ID;\n\npublic:\n    BikeRecord(string bikeName, int ID) : m_bikeName(bikeName), m_ID(ID)\n    {\n    }\n\n    void print() override\n    {\n        cout << \"Bike Record\" << endl\n             << \"Name  : \" << m_bikeName << endl\n             << \"Number: \" << m_ID << endl << endl;\n    }\n\n    unique_ptr<Record> clone() override\n    {\n        return make_unique<BikeRecord>(*this);\n    }\n};\n\n/** PersonRecord is the Concrete Prototype */\nclass PersonRecord : public Record\n{\nprivate:\n    string m_personName;\n    int m_age;\n\npublic:\n    PersonRecord(string personName, int age) : m_personName(personName), m_age(age)\n    {\n    }\n\n    void print() override\n    {\n        cout << \"Person Record\" << endl\n            << \"Name : \" << m_personName << endl\n            << \"Age  : \" << m_age << endl << endl;\n    }\n\n    unique_ptr<Record> clone() override\n    {\n        return make_unique<PersonRecord>(*this);\n    }\n};\n\n/** Opaque record type, avoids exposing concrete implementations */\nenum RecordType\n{\n    CAR,\n    BIKE,\n    PERSON\n};\n\n/** RecordFactory is the client */\nclass RecordFactory\n{\nprivate:\n    unordered_map<RecordType, unique_ptr<Record>, hash<int> > m_records;\n\npublic:\n    RecordFactory()\n    {\n        m_records[CAR]    = make_unique<CarRecord>(\"Ferrari\", 5050);\n        m_records[BIKE]   = make_unique<BikeRecord>(\"Yamaha\", 2525);\n        m_records[PERSON] = make_unique<PersonRecord>(\"Tom\", 25);\n    }\n\n    unique_ptr<Record> createRecord(RecordType recordType)\n    {\n        return m_records[recordType]->clone();\n    }\n};\n\nint main()\n{\n    RecordFactory recordFactory;\n\n    auto record = recordFactory.createRecord(CAR);\n    record->print();\n\n    record = recordFactory.createRecord(BIKE);\n    record->print();\n\n    record = recordFactory.createRecord(PERSON);\n    record->print();\n}"
  },
  {
    "name": "Command",
    "info": "Abstract the base input from the output",
    "content": "/*\nommand pattern is an Object behavioral pattern that decouples sender and receiver by encapsulating a request as an object,\nthereby letting you parameterize clients with different requests, queue or log requests, and support undo-able operations.\nIt can also be thought as an object oriented equivalent of call back method.\n*/\n\n#include <iostream>\n\nusing namespace std;\n\n/*the Command interface*/\nclass Command \n{\npublic:\n    virtual void execute()=0; //undefined (must be defined in a subclass)\n};\n\n/*Receiver class*/\nclass Light {\n\npublic:\n    Light() {  }\n\n    void turnOn() \n    {\n        cout << \"The light is on\" << endl;\n    }\n\n    void turnOff() \n    {\n        cout << \"The light is off\" << endl;\n    }\n};\n\n/*the Command for turning on the light*/\nclass FlipUpCommand: public Command \n{\npublic:\n\n    FlipUpCommand(Light& light):theLight(light)\n    {\n\n    }\n\n    virtual void execute()\n    {\n        theLight.turnOn();\n    }\n\nprivate:\n    Light& theLight;\n};\n\n/*the Command for turning off the light*/\nclass FlipDownCommand: public Command\n{\npublic:   \n    FlipDownCommand(Light& light) :theLight(light)\n    {\n\n    }\n    virtual void execute() \n    {\n        theLight.turnOff();\n    }\nprivate:\n    Light& theLight;\n};\n\nclass Switch {\npublic:\n    Switch(Command& flipUpCmd, Command& flipDownCmd)\n    :flipUpCommand(flipUpCmd),flipDownCommand(flipDownCmd)\n    {\n\n    }\n\n    void flipUp()\n    {\n        flipUpCommand.execute();\n    }\n\n    void flipDown()\n    {\n        flipDownCommand.execute();\n    }\n\nprivate:\n    Command& flipUpCommand;\n    Command& flipDownCommand;\n};\n\n \n/*The test class or client*/\nint main() \n{\n    Light lamp;\n    FlipUpCommand switchUp(lamp);\n    FlipDownCommand switchDown(lamp);\n\n    Switch s(switchUp, switchDown);\n    s.flipUp();\n    s.flipDown();\n}"
  },
  {
    "name": "Observer",
    "info": "The observer objects will be notified if something happend to the observable object",
    "content": "/*\nThe Observer Pattern defines a one-to-many dependency between objects so that when one object changes state,\nall its dependents are notified and updated automatically.\n*/\n\n#include <list>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n// The Abstract Observer\nclass ObserverBoardInterface\n{\npublic:\n    virtual void update(float a,float b,float c) = 0;\n};\n\n// Abstract Interface for Displays\nclass DisplayBoardInterface\n{\npublic:\n    virtual void show() = 0;\n};\n\n// The Abstract Subject\nclass WeatherDataInterface\n{\npublic:\n    virtual void registerOb(ObserverBoardInterface* ob) = 0;\n    virtual void removeOb(ObserverBoardInterface* ob) = 0;\n    virtual void notifyOb() = 0;\n};\n\n// The Concrete Subject\nclass ParaWeatherData: public WeatherDataInterface\n{\npublic:\n    void SensorDataChange(float a,float b,float c)\n    {\n        m_humidity = a;\n        m_temperature = b;\n        m_pressure = c;\n        notifyOb();\n    }\n\n    void registerOb(ObserverBoardInterface* ob)\n    {\n        m_obs.push_back(ob);\n    }\n\n    void removeOb(ObserverBoardInterface* ob)\n    {\n        m_obs.remove(ob);\n    }\nprotected:\n    void notifyOb()\n    {\n        list<ObserverBoardInterface*>::iterator pos = m_obs.begin();\n        while (pos != m_obs.end())\n        {\n            ((ObserverBoardInterface* )(*pos))->update(m_humidity,m_temperature,m_pressure);\n            (dynamic_cast<DisplayBoardInterface*>(*pos))->show();\n            ++pos;\n        }\n    }\n\nprivate:\n    float        m_humidity;\n    float        m_temperature;\n    float        m_pressure;\n    list<ObserverBoardInterface* > m_obs;\n};\n\n// A Concrete Observer\nclass CurrentConditionBoard : public ObserverBoardInterface, public DisplayBoardInterface\n{\npublic:\n    CurrentConditionBoard(ParaWeatherData& a):m_data(a)\n    {\n        m_data.registerOb(this);\n    }\n    void show()\n    {\n        cout<<\"_____CurrentConditionBoard_____\"<<endl;\n        cout<<\"humidity: \"<<m_h<<endl;\n        cout<<\"temperature: \"<<m_t<<endl;\n        cout<<\"pressure: \"<<m_p<<endl;\n        cout<<\"_______________________________\"<<endl;\n    }\n\n    void update(float h, float t, float p)\n    {\n        m_h = h;\n        m_t = t;\n        m_p = p;\n    }\n\nprivate:\n    float m_h;\n    float m_t;\n    float m_p;\n    ParaWeatherData& m_data;\n};\n\n// A Concrete Observer\nclass StatisticBoard : public ObserverBoardInterface, public DisplayBoardInterface\n{\npublic:\n    StatisticBoard(ParaWeatherData& a):m_maxt(-1000),m_mint(1000),m_avet(0),m_count(0),m_data(a)\n    {\n        m_data.registerOb(this);\n    }\n\n    void show()\n    {\n        cout<<\"________StatisticBoard_________\"<<endl;\n        cout<<\"lowest  temperature: \"<<m_mint<<endl;\n        cout<<\"highest temperature: \"<<m_maxt<<endl;\n        cout<<\"average temperature: \"<<m_avet<<endl;\n        cout<<\"_______________________________\"<<endl;\n    }\n\n    void update(float h, float t, float p)\n    {\n        ++m_count;\n        if (t>m_maxt)\n        {\n            m_maxt = t;\n        }\n        if (t<m_mint)\n        {\n            m_mint = t;\n        }\n        m_avet = (m_avet * (m_count-1) + t)/m_count;\n    }\n\nprivate:\n    float m_maxt;\n    float  m_mint;\n    float m_avet;\n    int m_count;\n    ParaWeatherData& m_data;\n};\n\n\nint main(int argc, char *argv[])\n{\n   \n    ParaWeatherData * wdata = new ParaWeatherData;\n    CurrentConditionBoard* currentB = new CurrentConditionBoard(*wdata);\n    StatisticBoard* statisticB = new StatisticBoard(*wdata);\n\n    wdata->SensorDataChange(10.2, 28.2, 1001);\n    wdata->SensorDataChange(12, 30.12, 1003);\n    wdata->SensorDataChange(10.2, 26, 806);\n    wdata->SensorDataChange(10.3, 35.9, 900);\n\n    wdata->removeOb(currentB);\n\n    wdata->SensorDataChange(100, 40, 1900);  \n    \n    delete statisticB;\n    delete currentB;\n    delete wdata;\n\n    return 0;\n}"
  },
  {
    "name": "State machine",
    "info": "Switch between different states depending on the current condition",
    "content": "/*\nThe State Pattern allows an object to alter its behavior when its internal state changes. The object will appear as having changed its class.\nThis is more bugprone that a lot of if statements/ nested if's\n*/\n\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <memory>\n\nenum Input {DUCK_DOWN, STAND_UP, JUMP, DIVE};\n\nclass Fighter;\nclass StandingState;  class JumpingState;  class DivingState;\n\nclass FighterState {\n    public:\n        static std::shared_ptr<StandingState> standing;\n        static std::shared_ptr<DivingState> diving;\n        virtual ~FighterState() = default;\n        virtual void handleInput (Fighter&, Input) = 0;\n        virtual void update (Fighter&) = 0;\n};\n\nclass DuckingState : public FighterState {\n    private:\n        int chargingTime;\n        static const int FullRestTime = 5;\n    public:\n        DuckingState() : chargingTime(0) {}\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nclass StandingState : public FighterState {\n    public:\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nclass JumpingState : public FighterState {\n    private:\n        int jumpingHeight;\n    public:\n        JumpingState() {jumpingHeight = std::rand() % 5 + 1;}\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nclass DivingState : public FighterState {\n    public:\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nstd::shared_ptr<StandingState> FighterState::standing (new StandingState);\nstd::shared_ptr<DivingState> FighterState::diving (new DivingState);\n\nclass Fighter {\n    private:\n        std::string name;\n        std::shared_ptr<FighterState> state;\n        int fatigueLevel = std::rand() % 10;\n    public:\n        Fighter (const std::string& newName) : name (newName), state (FighterState::standing) {}\n        std::string getName() const {return name;}\n        int getFatigueLevel() const {return fatigueLevel;}\n        virtual void handleInput (Input input) {state->handleInput (*this, input);}  // delegate input handling to 'state'.\n        void changeState (std::shared_ptr<FighterState> newState) {state = newState;  updateWithNewState();}\n        void standsUp() {std::cout << getName() << \" stands up.\" << std::endl;}\n        void ducksDown() {std::cout << getName() << \" ducks down.\" << std::endl;}\n        void jumps() {std::cout << getName() << \" jumps into the air.\" << std::endl;}\n        void dives() {std::cout << getName() << \" makes a dive attack in the middle of the jump!\" << std::endl;}\n        void feelsStrong() {std::cout << getName() << \" feels strong!\" << std::endl;}\n        void changeFatigueLevelBy (int change) {fatigueLevel += change;  std::cout << \"fatigueLevel = \" << fatigueLevel << std::endl;}\n    private:\n        virtual void updateWithNewState() {state->update(*this);}  // delegate updating to 'state'\n};\n\nvoid StandingState::handleInput (Fighter& fighter, Input input)  {\n    switch (input) {\n        case STAND_UP:  std::cout << fighter.getName() << \" remains standing.\" << std::endl;  return;\n        case DUCK_DOWN:  fighter.changeState (std::shared_ptr<DuckingState> (new DuckingState));  return fighter.ducksDown();\n        case JUMP:  fighter.jumps();  return fighter.changeState (std::shared_ptr<JumpingState> (new JumpingState));\n        default:  std::cout << \"One cannot do that while standing.  \" << fighter.getName() << \" remains standing by default.\" << std::endl;\n    }\n}\n\nvoid StandingState::update (Fighter& fighter) {\n    if (fighter.getFatigueLevel() > 0)\n        fighter.changeFatigueLevelBy(-1);\n}\n\nvoid DuckingState::handleInput (Fighter& fighter, Input input)  {\n    switch (input) {\n        case STAND_UP:  fighter.changeState (FighterState::standing);  return fighter.standsUp();\n        case DUCK_DOWN:\n            std::cout << fighter.getName() << \" remains in ducking position, \";\n            if (chargingTime < FullRestTime) std::cout << \"recovering in the meantime.\" << std::endl;\n            else std::cout << \"fully recovered.\" << std::endl;\n            return update (fighter);\n        default:\n            std::cout << \"One cannot do that while ducking.  \" << fighter.getName() << \" remains in ducking position by default.\" << std::endl;\n            update (fighter);\n    }\n}\n\nvoid DuckingState::update (Fighter& fighter) {\n    chargingTime++;\n    std::cout << \"Charging time = \" << chargingTime << \".\" << std::endl;\n    if (fighter.getFatigueLevel() > 0)\n        fighter.changeFatigueLevelBy(-1);\n    if (chargingTime >= FullRestTime && fighter.getFatigueLevel() <= 3)\n        fighter.feelsStrong();\n}\n\nvoid JumpingState::handleInput (Fighter& fighter, Input input)  {\n    switch (input) {\n        case DIVE:  fighter.changeState (FighterState::diving);  return fighter.dives();\n        default:\n            std::cout << \"One cannot do that in the middle of a jump.  \" << fighter.getName() << \" lands from his jump and is now standing again.\" << std::endl;\n            fighter.changeState (FighterState::standing);\n    }\n}\n\nvoid JumpingState::update (Fighter& fighter) {\n    std::cout << fighter.getName() << \" has jumped \" << jumpingHeight << \" feet into the air.\" << std::endl;\n    if (jumpingHeight >= 3)\n        fighter.changeFatigueLevelBy(1);\n}\n\nvoid DivingState::handleInput (Fighter& fighter, Input)  {\n    std::cout << \"Regardless of what the user input is, \" << fighter.getName() << \" lands from his dive and is now standing again.\" << std::endl;\n    fighter.changeState (FighterState::standing);\n}\n\nvoid DivingState::update (Fighter& fighter) {\n    fighter.changeFatigueLevelBy(2);\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n    Fighter rex (\"Rex the Fighter\"), borg (\"Borg the Fighter\");\n    std::cout << rex.getName() << \" and \" << borg.getName() << \" are currently standing.\" << std::endl;\n    int choice;\n    auto chooseAction = [&choice](Fighter& fighter) {\n        std::cout << std::endl << DUCK_DOWN + 1 << \") Duck down  \" << STAND_UP + 1 << \") Stand up  \" << JUMP + 1\n            << \") Jump  \" << DIVE + 1 << \") Dive in the middle of a jump\" << std::endl;\n        std::cout << \"Choice for \" << fighter.getName() << \"? \";\n        std::cin >> choice;\n        const Input input1 = static_cast<Input>(choice - 1);\n        fighter.handleInput (input1);    \n    };\n    while (true) {\n        chooseAction (rex);\n        chooseAction (borg);\n    }\n}"
  },
  {
    "name": "Flyweight",
    "info": "Make data that is shared between object commen instead of having multiple equal instances",
    "content": "/*\nThe pattern for saving memory (basically) by sharing properties of objects. Imagine a huge number of similar objects which all have most of their properties the same.\nIt is natural to move these properties out of these objects to some external data structure and provide each object with the link to that data structure.\n*/\n\n#include <iostream>\n#include <string>\n#include <vector>\n\n#define NUMBER_OF_SAME_TYPE_CHARS 3;\n\n/* Actual flyweight objects class (declaration) */\nclass FlyweightCharacter;\n\n/*\n    FlyweightCharacterAbstractBuilder is a class holding the properties which are shared by\n    many objects. So instead of keeping these properties in those objects we keep them externally, making\n    objects flyweight. See more details in the comments of main function.\n*/\nclass FlyweightCharacterAbstractBuilder {\n    FlyweightCharacterAbstractBuilder() {}\n    ~FlyweightCharacterAbstractBuilder() {}\npublic:\n    static std::vector<float> fontSizes; // lets imagine that sizes may be of floating point type\n    static std::vector<std::string> fontNames; // font name may be of variable length (lets take 6 bytes is average)\n\n    static void setFontsAndNames();\n    static FlyweightCharacter createFlyweightCharacter(unsigned short fontSizeIndex,\n        unsigned short fontNameIndex,\n        unsigned short positionInStream);\n};\n\nstd::vector<float> FlyweightCharacterAbstractBuilder::fontSizes(3);\nstd::vector<std::string> FlyweightCharacterAbstractBuilder::fontNames(3);\nvoid FlyweightCharacterAbstractBuilder::setFontsAndNames() {\n    fontSizes[0] = 1.0;\n    fontSizes[1] = 1.5;\n    fontSizes[2] = 2.0;\n\n    fontNames[0] = \"first_font\";\n    fontNames[1] = \"second_font\";\n    fontNames[2] = \"third_font\";\n}\n\nclass FlyweightCharacter {\n    unsigned short fontSizeIndex; // index instead of actual font size\n    unsigned short fontNameIndex; // index instead of font name\n\n    unsigned positionInStream;\n\npublic:\n\n    FlyweightCharacter(unsigned short fontSizeIndex, unsigned short fontNameIndex, unsigned short positionInStream):\n        fontSizeIndex(fontSizeIndex), fontNameIndex(fontNameIndex), positionInStream(positionInStream) {}\n    void print() {\n        std::cout << \"Font Size: \" << FlyweightCharacterAbstractBuilder::fontSizes[fontSizeIndex]\n            << \", font Name: \" << FlyweightCharacterAbstractBuilder::fontNames[fontNameIndex]\n            << \", character stream position: \" << positionInStream << std::endl;\n    }\n    ~FlyweightCharacter() {}\n};\n\nFlyweightCharacter FlyweightCharacterAbstractBuilder::createFlyweightCharacter(unsigned short fontSizeIndex, unsigned short fontNameIndex, unsigned short positionInStream) {\n    FlyweightCharacter fc(fontSizeIndex, fontNameIndex, positionInStream);\n\n    return fc;\n}\n\nint main(int argc, char** argv) {\n    std::vector<FlyweightCharacter> chars;\n\n    FlyweightCharacterAbstractBuilder::setFontsAndNames();\n    unsigned short limit = NUMBER_OF_SAME_TYPE_CHARS;\n\n    for (unsigned short i = 0; i < limit; i++) {\n        chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(0, 0, i));\n        chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(1, 1, i + 1 * limit));\n        chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(2, 2, i + 2 * limit));\n    }\n    /*\n        Each char stores links to its fontName and fontSize so what we get is:\n\n        each object instead of allocating 6 bytes (convention above) for string\n        and 4 bytes for float allocates 2 bytes for fontNameIndex and fontSizeIndex.\n\n        That means for each char we save 6 + 4 - 2 - 2 = 6 bytes.\n        Now imagine we have NUMBER_OF_SAME_TYPE_CHARS = 1000 i.e. with our code\n        we will have 3 groups of chars with 1000 chars in each group which will save \n        3 * 1000 * 6 - (3 * 6 + 3 * 4) = 17970 saved bytes.\n\n        3 * 6 + 3 * 4 is a number of bytes allocated by FlyweightCharacterAbstractBuilder.\n\n        So the idea of the pattern is to move properties shared by many objects to some\n        external container. The objects in that case don't store the data themselves they\n        store only links to the data which saves memory and make the objects lighter.\n        The data size of properties stored externally may be significant which will save REALLY\n        huge amount of memory and will make each object super light in comparison to its counterpart.\n        That's where the name of the pattern comes from: flyweight (i.e. very light).\n    */\n    for (unsigned short i = 0; i < chars.size(); i++) {\n        chars[i].print();\n    }\n\n    std::cin.get(); return 0;\n}"
  },
  {
    "name": "Builder",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Factory",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Adapter",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Bridge",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Composite",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Decorator",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Facade",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Proxy",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Curiously recurring template",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Interface based programming",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Chain of Reponsibility",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Iterator",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Mediator",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Memento",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Strategy",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Template Method",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Visitor",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  },
  {
    "name": "Model-View-Controller",
    "info": "Example",
    "content": "function _(id) { document.getElementbyId(id); }"
  }
]