[
  {
    "name": "Singleton",
    "info": "Make only one instance of the object (is overused)",
    "content": "/*\nThe Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance.\nIt is named after the singleton set, which is defined to be a set containing one element. \nThis is useful when exactly one object is needed to coordinate actions across the system.\n*/\n\nclass StringSingleton\n {\n public:\n     // Some accessor functions for the class, itself\n     std::string GetString() const \n     {return mString;}\n     void SetString(const std::string &newStr)\n     {mString = newStr;}\n \n     // The magic function, which allows access to the class from anywhere\n     // To get the value of the instance of the class, call:\n     //     StringSingleton::Instance().GetString();\n     static StringSingleton &Instance()\n     {\n         // This line only runs once, thus creating the only instance in existence\n         static std::auto_ptr<StringSingleton> instance( new StringSingleton );\n         // dereferencing the variable here, saves the caller from having to use \n         // the arrow operator, and removes temptation to try and delete the \n         // returned instance.\n         return *instance; // always returns the same instance\n     }\n \n private: \n     // We need to make some given functions private to finish the definition of the singleton\n     StringSingleton(){} // default constructor available only to members or friends of this class\n \n     // Note that the next two functions are not given bodies, thus any attempt \n     // to call them implicitly will return as compiler errors. This prevents \n     // accidental copying of the only instance of the class.\n     StringSingleton(const StringSingleton &old); // disallow copy constructor\n     const StringSingleton &operator=(const StringSingleton &old); //disallow assignment operator\n \n     // Note that although this should be allowed, \n     // some compilers may not implement private destructors\n     // This prevents others from deleting our one single instance, which was otherwise created on the heap\n     ~StringSingleton(){} \n private: // private data for an instance of this class\n     std::string mString;\n };\n\n int main(){\n    StringSingleton::Instance(); //only way to get the singleton object\n }"
  },
  {
    "name": "Prototype",
    "info": "Prototype is used when a full clone is to expensive and costly",
    "content": "/*\nA prototype pattern is used in software development when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.\nThis pattern is used, for example, when the inherent cost of creating a new object in the standard way (e.g., using the new keyword) is prohibitively expensive for a given application.\n*/\n\n/** Implementation of Prototype Method **/\n#include <iostream>\n#include <unordered_map>\n#include <string>\n#include <memory>\nusing namespace std;\n\n/** Record is the base Prototype */\nclass Record\n{\npublic:\n    virtual ~Record() {}\n    virtual void print() = 0;\n    virtual unique_ptr<Record> clone() = 0;\n};\n\n/** CarRecord is a Concrete Prototype */\nclass CarRecord : public Record\n{\nprivate:\n    string m_carName;\n    int m_ID;\n\npublic:\n    CarRecord(string carName, int ID) : m_carName(carName), m_ID(ID)\n    {\n    }\n\n    void print() override\n    {\n        cout << \"Car Record\" << endl\n             << \"Name  : \"   << m_carName << endl\n             << \"Number: \"   << m_ID << endl << endl;\n    }\n\n    unique_ptr<Record> clone() override\n    {\n        return make_unique<CarRecord>(*this);\n    }\n};\n\n/** BikeRecord is the Concrete Prototype */\nclass BikeRecord : public Record\n{\nprivate:\n    string m_bikeName;\n    int m_ID;\n\npublic:\n    BikeRecord(string bikeName, int ID) : m_bikeName(bikeName), m_ID(ID)\n    {\n    }\n\n    void print() override\n    {\n        cout << \"Bike Record\" << endl\n             << \"Name  : \" << m_bikeName << endl\n             << \"Number: \" << m_ID << endl << endl;\n    }\n\n    unique_ptr<Record> clone() override\n    {\n        return make_unique<BikeRecord>(*this);\n    }\n};\n\n/** PersonRecord is the Concrete Prototype */\nclass PersonRecord : public Record\n{\nprivate:\n    string m_personName;\n    int m_age;\n\npublic:\n    PersonRecord(string personName, int age) : m_personName(personName), m_age(age)\n    {\n    }\n\n    void print() override\n    {\n        cout << \"Person Record\" << endl\n            << \"Name : \" << m_personName << endl\n            << \"Age  : \" << m_age << endl << endl;\n    }\n\n    unique_ptr<Record> clone() override\n    {\n        return make_unique<PersonRecord>(*this);\n    }\n};\n\n/** Opaque record type, avoids exposing concrete implementations */\nenum RecordType\n{\n    CAR,\n    BIKE,\n    PERSON\n};\n\n/** RecordFactory is the client */\nclass RecordFactory\n{\nprivate:\n    unordered_map<RecordType, unique_ptr<Record>, hash<int> > m_records;\n\npublic:\n    RecordFactory()\n    {\n        m_records[CAR]    = make_unique<CarRecord>(\"Ferrari\", 5050);\n        m_records[BIKE]   = make_unique<BikeRecord>(\"Yamaha\", 2525);\n        m_records[PERSON] = make_unique<PersonRecord>(\"Tom\", 25);\n    }\n\n    unique_ptr<Record> createRecord(RecordType recordType)\n    {\n        return m_records[recordType]->clone();\n    }\n};\n\nint main()\n{\n    RecordFactory recordFactory;\n\n    auto record = recordFactory.createRecord(CAR);\n    record->print();\n\n    record = recordFactory.createRecord(BIKE);\n    record->print();\n\n    record = recordFactory.createRecord(PERSON);\n    record->print();\n}"
  },
  {
    "name": "Command",
    "info": "Abstract the base input from the output",
    "content": "/*\nommand pattern is an Object behavioral pattern that decouples sender and receiver by encapsulating a request as an object,\nthereby letting you parameterize clients with different requests, queue or log requests, and support undo-able operations.\nIt can also be thought as an object oriented equivalent of call back method.\n*/\n\n#include <iostream>\n\nusing namespace std;\n\n/*the Command interface*/\nclass Command \n{\npublic:\n    virtual void execute()=0; //undefined (must be defined in a subclass)\n};\n\n/*Receiver class*/\nclass Light {\n\npublic:\n    Light() {  }\n\n    void turnOn() \n    {\n        cout << \"The light is on\" << endl;\n    }\n\n    void turnOff() \n    {\n        cout << \"The light is off\" << endl;\n    }\n};\n\n/*the Command for turning on the light*/\nclass FlipUpCommand: public Command \n{\npublic:\n\n    FlipUpCommand(Light& light):theLight(light)\n    {\n\n    }\n\n    virtual void execute()\n    {\n        theLight.turnOn();\n    }\n\nprivate:\n    Light& theLight;\n};\n\n/*the Command for turning off the light*/\nclass FlipDownCommand: public Command\n{\npublic:   \n    FlipDownCommand(Light& light) :theLight(light)\n    {\n\n    }\n    virtual void execute() \n    {\n        theLight.turnOff();\n    }\nprivate:\n    Light& theLight;\n};\n\nclass Switch {\npublic:\n    Switch(Command& flipUpCmd, Command& flipDownCmd)\n    :flipUpCommand(flipUpCmd),flipDownCommand(flipDownCmd)\n    {\n\n    }\n\n    void flipUp()\n    {\n        flipUpCommand.execute();\n    }\n\n    void flipDown()\n    {\n        flipDownCommand.execute();\n    }\n\nprivate:\n    Command& flipUpCommand;\n    Command& flipDownCommand;\n};\n\n \n/*The test class or client*/\nint main() \n{\n    Light lamp;\n    FlipUpCommand switchUp(lamp);\n    FlipDownCommand switchDown(lamp);\n\n    Switch s(switchUp, switchDown);\n    s.flipUp();\n    s.flipDown();\n}"
  },
  {
    "name": "Observer",
    "info": "The observer objects will be notified if something happend to the observable object",
    "content": "/*\nThe Observer Pattern defines a one-to-many dependency between objects so that when one object changes state,\nall its dependents are notified and updated automatically.\n*/\n\n#include <list>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n// The Abstract Observer\nclass ObserverBoardInterface\n{\npublic:\n    virtual void update(float a,float b,float c) = 0;\n};\n\n// Abstract Interface for Displays\nclass DisplayBoardInterface\n{\npublic:\n    virtual void show() = 0;\n};\n\n// The Abstract Subject\nclass WeatherDataInterface\n{\npublic:\n    virtual void registerOb(ObserverBoardInterface* ob) = 0;\n    virtual void removeOb(ObserverBoardInterface* ob) = 0;\n    virtual void notifyOb() = 0;\n};\n\n// The Concrete Subject\nclass ParaWeatherData: public WeatherDataInterface\n{\npublic:\n    void SensorDataChange(float a,float b,float c)\n    {\n        m_humidity = a;\n        m_temperature = b;\n        m_pressure = c;\n        notifyOb();\n    }\n\n    void registerOb(ObserverBoardInterface* ob)\n    {\n        m_obs.push_back(ob);\n    }\n\n    void removeOb(ObserverBoardInterface* ob)\n    {\n        m_obs.remove(ob);\n    }\nprotected:\n    void notifyOb()\n    {\n        list<ObserverBoardInterface*>::iterator pos = m_obs.begin();\n        while (pos != m_obs.end())\n        {\n            ((ObserverBoardInterface* )(*pos))->update(m_humidity,m_temperature,m_pressure);\n            (dynamic_cast<DisplayBoardInterface*>(*pos))->show();\n            ++pos;\n        }\n    }\n\nprivate:\n    float        m_humidity;\n    float        m_temperature;\n    float        m_pressure;\n    list<ObserverBoardInterface* > m_obs;\n};\n\n// A Concrete Observer\nclass CurrentConditionBoard : public ObserverBoardInterface, public DisplayBoardInterface\n{\npublic:\n    CurrentConditionBoard(ParaWeatherData& a):m_data(a)\n    {\n        m_data.registerOb(this);\n    }\n    void show()\n    {\n        cout<<\"_____CurrentConditionBoard_____\"<<endl;\n        cout<<\"humidity: \"<<m_h<<endl;\n        cout<<\"temperature: \"<<m_t<<endl;\n        cout<<\"pressure: \"<<m_p<<endl;\n        cout<<\"_______________________________\"<<endl;\n    }\n\n    void update(float h, float t, float p)\n    {\n        m_h = h;\n        m_t = t;\n        m_p = p;\n    }\n\nprivate:\n    float m_h;\n    float m_t;\n    float m_p;\n    ParaWeatherData& m_data;\n};\n\n// A Concrete Observer\nclass StatisticBoard : public ObserverBoardInterface, public DisplayBoardInterface\n{\npublic:\n    StatisticBoard(ParaWeatherData& a):m_maxt(-1000),m_mint(1000),m_avet(0),m_count(0),m_data(a)\n    {\n        m_data.registerOb(this);\n    }\n\n    void show()\n    {\n        cout<<\"________StatisticBoard_________\"<<endl;\n        cout<<\"lowest  temperature: \"<<m_mint<<endl;\n        cout<<\"highest temperature: \"<<m_maxt<<endl;\n        cout<<\"average temperature: \"<<m_avet<<endl;\n        cout<<\"_______________________________\"<<endl;\n    }\n\n    void update(float h, float t, float p)\n    {\n        ++m_count;\n        if (t>m_maxt)\n        {\n            m_maxt = t;\n        }\n        if (t<m_mint)\n        {\n            m_mint = t;\n        }\n        m_avet = (m_avet * (m_count-1) + t)/m_count;\n    }\n\nprivate:\n    float m_maxt;\n    float  m_mint;\n    float m_avet;\n    int m_count;\n    ParaWeatherData& m_data;\n};\n\n\nint main(int argc, char *argv[])\n{\n   \n    ParaWeatherData * wdata = new ParaWeatherData;\n    CurrentConditionBoard* currentB = new CurrentConditionBoard(*wdata);\n    StatisticBoard* statisticB = new StatisticBoard(*wdata);\n\n    wdata->SensorDataChange(10.2, 28.2, 1001);\n    wdata->SensorDataChange(12, 30.12, 1003);\n    wdata->SensorDataChange(10.2, 26, 806);\n    wdata->SensorDataChange(10.3, 35.9, 900);\n\n    wdata->removeOb(currentB);\n\n    wdata->SensorDataChange(100, 40, 1900);  \n    \n    delete statisticB;\n    delete currentB;\n    delete wdata;\n\n    return 0;\n}"
  },
  {
    "name": "State machine",
    "info": "Switch between different states depending on the current condition",
    "content": "/*\nThe State Pattern allows an object to alter its behavior when its internal state changes. The object will appear as having changed its class.\nThis is more bugprone that a lot of if statements/ nested if's\n*/\n\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <memory>\n\nenum Input {DUCK_DOWN, STAND_UP, JUMP, DIVE};\n\nclass Fighter;\nclass StandingState;  class JumpingState;  class DivingState;\n\nclass FighterState {\n    public:\n        static std::shared_ptr<StandingState> standing;\n        static std::shared_ptr<DivingState> diving;\n        virtual ~FighterState() = default;\n        virtual void handleInput (Fighter&, Input) = 0;\n        virtual void update (Fighter&) = 0;\n};\n\nclass DuckingState : public FighterState {\n    private:\n        int chargingTime;\n        static const int FullRestTime = 5;\n    public:\n        DuckingState() : chargingTime(0) {}\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nclass StandingState : public FighterState {\n    public:\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nclass JumpingState : public FighterState {\n    private:\n        int jumpingHeight;\n    public:\n        JumpingState() {jumpingHeight = std::rand() % 5 + 1;}\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nclass DivingState : public FighterState {\n    public:\n        virtual void handleInput (Fighter&, Input) override;\n        virtual void update (Fighter&) override;\n};\n\nstd::shared_ptr<StandingState> FighterState::standing (new StandingState);\nstd::shared_ptr<DivingState> FighterState::diving (new DivingState);\n\nclass Fighter {\n    private:\n        std::string name;\n        std::shared_ptr<FighterState> state;\n        int fatigueLevel = std::rand() % 10;\n    public:\n        Fighter (const std::string& newName) : name (newName), state (FighterState::standing) {}\n        std::string getName() const {return name;}\n        int getFatigueLevel() const {return fatigueLevel;}\n        virtual void handleInput (Input input) {state->handleInput (*this, input);}  // delegate input handling to 'state'.\n        void changeState (std::shared_ptr<FighterState> newState) {state = newState;  updateWithNewState();}\n        void standsUp() {std::cout << getName() << \" stands up.\" << std::endl;}\n        void ducksDown() {std::cout << getName() << \" ducks down.\" << std::endl;}\n        void jumps() {std::cout << getName() << \" jumps into the air.\" << std::endl;}\n        void dives() {std::cout << getName() << \" makes a dive attack in the middle of the jump!\" << std::endl;}\n        void feelsStrong() {std::cout << getName() << \" feels strong!\" << std::endl;}\n        void changeFatigueLevelBy (int change) {fatigueLevel += change;  std::cout << \"fatigueLevel = \" << fatigueLevel << std::endl;}\n    private:\n        virtual void updateWithNewState() {state->update(*this);}  // delegate updating to 'state'\n};\n\nvoid StandingState::handleInput (Fighter& fighter, Input input)  {\n    switch (input) {\n        case STAND_UP:  std::cout << fighter.getName() << \" remains standing.\" << std::endl;  return;\n        case DUCK_DOWN:  fighter.changeState (std::shared_ptr<DuckingState> (new DuckingState));  return fighter.ducksDown();\n        case JUMP:  fighter.jumps();  return fighter.changeState (std::shared_ptr<JumpingState> (new JumpingState));\n        default:  std::cout << \"One cannot do that while standing.  \" << fighter.getName() << \" remains standing by default.\" << std::endl;\n    }\n}\n\nvoid StandingState::update (Fighter& fighter) {\n    if (fighter.getFatigueLevel() > 0)\n        fighter.changeFatigueLevelBy(-1);\n}\n\nvoid DuckingState::handleInput (Fighter& fighter, Input input)  {\n    switch (input) {\n        case STAND_UP:  fighter.changeState (FighterState::standing);  return fighter.standsUp();\n        case DUCK_DOWN:\n            std::cout << fighter.getName() << \" remains in ducking position, \";\n            if (chargingTime < FullRestTime) std::cout << \"recovering in the meantime.\" << std::endl;\n            else std::cout << \"fully recovered.\" << std::endl;\n            return update (fighter);\n        default:\n            std::cout << \"One cannot do that while ducking.  \" << fighter.getName() << \" remains in ducking position by default.\" << std::endl;\n            update (fighter);\n    }\n}\n\nvoid DuckingState::update (Fighter& fighter) {\n    chargingTime++;\n    std::cout << \"Charging time = \" << chargingTime << \".\" << std::endl;\n    if (fighter.getFatigueLevel() > 0)\n        fighter.changeFatigueLevelBy(-1);\n    if (chargingTime >= FullRestTime && fighter.getFatigueLevel() <= 3)\n        fighter.feelsStrong();\n}\n\nvoid JumpingState::handleInput (Fighter& fighter, Input input)  {\n    switch (input) {\n        case DIVE:  fighter.changeState (FighterState::diving);  return fighter.dives();\n        default:\n            std::cout << \"One cannot do that in the middle of a jump.  \" << fighter.getName() << \" lands from his jump and is now standing again.\" << std::endl;\n            fighter.changeState (FighterState::standing);\n    }\n}\n\nvoid JumpingState::update (Fighter& fighter) {\n    std::cout << fighter.getName() << \" has jumped \" << jumpingHeight << \" feet into the air.\" << std::endl;\n    if (jumpingHeight >= 3)\n        fighter.changeFatigueLevelBy(1);\n}\n\nvoid DivingState::handleInput (Fighter& fighter, Input)  {\n    std::cout << \"Regardless of what the user input is, \" << fighter.getName() << \" lands from his dive and is now standing again.\" << std::endl;\n    fighter.changeState (FighterState::standing);\n}\n\nvoid DivingState::update (Fighter& fighter) {\n    fighter.changeFatigueLevelBy(2);\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n    Fighter rex (\"Rex the Fighter\"), borg (\"Borg the Fighter\");\n    std::cout << rex.getName() << \" and \" << borg.getName() << \" are currently standing.\" << std::endl;\n    int choice;\n    auto chooseAction = [&choice](Fighter& fighter) {\n        std::cout << std::endl << DUCK_DOWN + 1 << \") Duck down  \" << STAND_UP + 1 << \") Stand up  \" << JUMP + 1\n            << \") Jump  \" << DIVE + 1 << \") Dive in the middle of a jump\" << std::endl;\n        std::cout << \"Choice for \" << fighter.getName() << \"? \";\n        std::cin >> choice;\n        const Input input1 = static_cast<Input>(choice - 1);\n        fighter.handleInput (input1);    \n    };\n    while (true) {\n        chooseAction (rex);\n        chooseAction (borg);\n    }\n}"
  },
  {
    "name": "Flyweight",
    "info": "Make data that is shared between object common instead of having multiple equal instances",
    "content": "/*\nThe pattern for saving memory (basically) by sharing properties of objects. Imagine a huge number of similar objects which all have most of their properties the same.\nIt is natural to move these properties out of these objects to some external data structure and provide each object with the link to that data structure.\n*/\n\n#include <iostream>\n#include <string>\n#include <vector>\n\n#define NUMBER_OF_SAME_TYPE_CHARS 3;\n\n/* Actual flyweight objects class (declaration) */\nclass FlyweightCharacter;\n\n/*\n    FlyweightCharacterAbstractBuilder is a class holding the properties which are shared by\n    many objects. So instead of keeping these properties in those objects we keep them externally, making\n    objects flyweight. See more details in the comments of main function.\n*/\nclass FlyweightCharacterAbstractBuilder {\n    FlyweightCharacterAbstractBuilder() {}\n    ~FlyweightCharacterAbstractBuilder() {}\npublic:\n    static std::vector<float> fontSizes; // lets imagine that sizes may be of floating point type\n    static std::vector<std::string> fontNames; // font name may be of variable length (lets take 6 bytes is average)\n\n    static void setFontsAndNames();\n    static FlyweightCharacter createFlyweightCharacter(unsigned short fontSizeIndex,\n        unsigned short fontNameIndex,\n        unsigned short positionInStream);\n};\n\nstd::vector<float> FlyweightCharacterAbstractBuilder::fontSizes(3);\nstd::vector<std::string> FlyweightCharacterAbstractBuilder::fontNames(3);\nvoid FlyweightCharacterAbstractBuilder::setFontsAndNames() {\n    fontSizes[0] = 1.0;\n    fontSizes[1] = 1.5;\n    fontSizes[2] = 2.0;\n\n    fontNames[0] = \"first_font\";\n    fontNames[1] = \"second_font\";\n    fontNames[2] = \"third_font\";\n}\n\nclass FlyweightCharacter {\n    unsigned short fontSizeIndex; // index instead of actual font size\n    unsigned short fontNameIndex; // index instead of font name\n\n    unsigned positionInStream;\n\npublic:\n\n    FlyweightCharacter(unsigned short fontSizeIndex, unsigned short fontNameIndex, unsigned short positionInStream):\n        fontSizeIndex(fontSizeIndex), fontNameIndex(fontNameIndex), positionInStream(positionInStream) {}\n    void print() {\n        std::cout << \"Font Size: \" << FlyweightCharacterAbstractBuilder::fontSizes[fontSizeIndex]\n            << \", font Name: \" << FlyweightCharacterAbstractBuilder::fontNames[fontNameIndex]\n            << \", character stream position: \" << positionInStream << std::endl;\n    }\n    ~FlyweightCharacter() {}\n};\n\nFlyweightCharacter FlyweightCharacterAbstractBuilder::createFlyweightCharacter(unsigned short fontSizeIndex, unsigned short fontNameIndex, unsigned short positionInStream) {\n    FlyweightCharacter fc(fontSizeIndex, fontNameIndex, positionInStream);\n\n    return fc;\n}\n\nint main(int argc, char** argv) {\n    std::vector<FlyweightCharacter> chars;\n\n    FlyweightCharacterAbstractBuilder::setFontsAndNames();\n    unsigned short limit = NUMBER_OF_SAME_TYPE_CHARS;\n\n    for (unsigned short i = 0; i < limit; i++) {\n        chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(0, 0, i));\n        chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(1, 1, i + 1 * limit));\n        chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(2, 2, i + 2 * limit));\n    }\n    /*\n        Each char stores links to its fontName and fontSize so what we get is:\n\n        each object instead of allocating 6 bytes (convention above) for string\n        and 4 bytes for float allocates 2 bytes for fontNameIndex and fontSizeIndex.\n\n        That means for each char we save 6 + 4 - 2 - 2 = 6 bytes.\n        Now imagine we have NUMBER_OF_SAME_TYPE_CHARS = 1000 i.e. with our code\n        we will have 3 groups of chars with 1000 chars in each group which will save \n        3 * 1000 * 6 - (3 * 6 + 3 * 4) = 17970 saved bytes.\n\n        3 * 6 + 3 * 4 is a number of bytes allocated by FlyweightCharacterAbstractBuilder.\n\n        So the idea of the pattern is to move properties shared by many objects to some\n        external container. The objects in that case don't store the data themselves they\n        store only links to the data which saves memory and make the objects lighter.\n        The data size of properties stored externally may be significant which will save REALLY\n        huge amount of memory and will make each object super light in comparison to its counterpart.\n        That's where the name of the pattern comes from: flyweight (i.e. very light).\n    */\n    for (unsigned short i = 0; i < chars.size(); i++) {\n        chars[i].print();\n    }\n\n    std::cin.get(); return 0;\n}"
  },
  {
    "name": "Builder",
    "info": "The Builder Creational Pattern is used to separate the construction of a complex object from its representation so that the same construction process can create different objects representations.",
    "content": "/*\nProblem \n    We want to construct a complex object, however we do not want to have a complex constructor member or one that would need many arguments.\nSolution \n    Define an intermediate object whose member functions define the desired object part by part before the object is available to the client. Builder Pattern lets us defer the construction of the object until all the options for creation have been specified.\n*/\n\n#include <string>\n#include <iostream>\n#include <memory>\nusing namespace std;\n\n// \"Product\"\nclass Pizza\n{\npublic:\n    void setDough(const string& dough)\n    {\n        m_dough = dough;\n    }\n    void setSauce(const string& sauce)\n    {\n        m_sauce = sauce;\n    }\n    void setTopping(const string& topping)\n    {\n        m_topping = topping;\n    }\n    void open() const\n    {\n        cout << \"Pizza with \" << m_dough << \" dough, \" << m_sauce << \" sauce and \"\n            << m_topping << \" topping. Mmm.\" << endl;\n    }\nprivate:\n    string m_dough;\n    string m_sauce;\n    string m_topping;\n};\n\n// \"Abstract Builder\"\nclass PizzaBuilder\n{\npublic:\n    virtual ~PizzaBuilder() {};\n\n    Pizza* getPizza()\n    {\n        return m_pizza.release();\n    }\n    void createNewPizzaProduct()\n    {\n        m_pizza = make_unique<Pizza>();\n    }\n    virtual void buildDough() = 0;\n    virtual void buildSauce() = 0;\n    virtual void buildTopping() = 0;\nprotected:\n    unique_ptr<Pizza> m_pizza;\n};\n\n//----------------------------------------------------------------\n\nclass HawaiianPizzaBuilder : public PizzaBuilder\n{\npublic:\n    virtual ~HawaiianPizzaBuilder() {};\n\n    virtual void buildDough()\n    {\n        m_pizza->setDough(\"cross\");\n    }\n    virtual void buildSauce()\n    {\n        m_pizza->setSauce(\"mild\");\n    }\n    virtual void buildTopping()\n    {\n        m_pizza->setTopping(\"ham+pineapple\");\n    }\n};\n\nclass SpicyPizzaBuilder : public PizzaBuilder\n{\npublic:\n    virtual ~SpicyPizzaBuilder() {};\n\n    virtual void buildDough()\n    {\n        m_pizza->setDough(\"pan baked\");\n    }\n    virtual void buildSauce()\n    {\n        m_pizza->setSauce(\"hot\");\n    }\n    virtual void buildTopping()\n    {\n        m_pizza->setTopping(\"pepperoni+salami\");\n    }\n};\n\n//----------------------------------------------------------------\n\nclass Cook\n{\npublic:\n    void openPizza()\n    {\n        m_pizzaBuilder->getPizza()->open();\n    }\n    void makePizza(PizzaBuilder* pb)\n    {\n        m_pizzaBuilder = pb;\n        m_pizzaBuilder->createNewPizzaProduct();\n        m_pizzaBuilder->buildDough();\n        m_pizzaBuilder->buildSauce();\n        m_pizzaBuilder->buildTopping();\n    }\nprivate:\n    PizzaBuilder* m_pizzaBuilder;\n};\n\nint main()\n{\n    Cook cook;\n    HawaiianPizzaBuilder hawaiianPizzaBuilder;\n    SpicyPizzaBuilder    spicyPizzaBuilder;\n\n    cook.makePizza(&hawaiianPizzaBuilder);\n    cook.openPizza();\n\n    cook.makePizza(&spicyPizzaBuilder);\n    cook.openPizza();\n}"
  },
  {
    "name": "Factory",
    "info": "A utility class that creates an instance of a class from a family of derived classes",
    "content": "/*\nProblem \n    We want to decide at run time what object is to be created based on some configuration or application parameter. When we write the code, we do not know what class should be instantiated.\nSolution \n    Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\n*/\n\n#include <stdexcept>\n#include <iostream>\n#include <memory>\nusing namespace std;\n\nclass Pizza {\npublic:\n    virtual int getPrice() const = 0;\n    virtual ~Pizza() {};  /* without this, no destructor for derived Pizza's will be called. */\n};\n\nclass HamAndMushroomPizza : public Pizza {\npublic:\n    virtual int getPrice() const { return 850; };\n    virtual ~HamAndMushroomPizza() {};\n};\n\nclass DeluxePizza : public Pizza {\npublic:\n    virtual int getPrice() const { return 1050; };\n    virtual ~DeluxePizza() {};\n};\n\nclass HawaiianPizza : public Pizza {\npublic:\n    virtual int getPrice() const { return 1150; };\n    virtual ~HawaiianPizza() {};\n};\n\nclass PizzaFactory {\npublic:\n    enum PizzaType {\n        HamMushroom,\n        Deluxe,\n        Hawaiian\n    };\n\n    static unique_ptr<Pizza> createPizza(PizzaType pizzaType) {\n        switch (pizzaType) {\n        case HamMushroom: return make_unique<HamAndMushroomPizza>();\n        case Deluxe:      return make_unique<DeluxePizza>();\n        case Hawaiian:    return make_unique<HawaiianPizza>();\n        }\n        throw \"invalid pizza type.\";\n    }\n};\n\n/*\n* Create all available pizzas and print their prices\n*/\nvoid pizza_information(PizzaFactory::PizzaType pizzatype)\n{\n    unique_ptr<Pizza> pizza = PizzaFactory::createPizza(pizzatype);\n    cout << \"Price of \" << pizzatype << \" is \" << pizza->getPrice() << std::endl;\n}\n\nint main()\n{\n    pizza_information(PizzaFactory::HamMushroom);\n    pizza_information(PizzaFactory::Deluxe);\n    pizza_information(PizzaFactory::Hawaiian);\n}"
  },
  {
    "name": "Adapter",
    "info": "An adapter allows classes to work together that normally could not because of incompatible interfaces, by providing its interface to clients while using the original interface.",
    "content": "#include <iostream>\n#include <list>\n#include <cstdlib>\nusing namespace std;\n\n// Legacy account\nclass LegacyAccount\n{\n    int no;\n\npublic:\n    LegacyAccount(int no)\n    {\n        this->no = no;\n    }\n\n    void legacyAccountPrint()\n    {\n        cout << \"Display legacy account details \" << no << endl;\n    }\n};\n\n// Renewed interface\nclass RenewedAccountIntf\n{\npublic:\n    virtual void display() = 0;\n};\n\n// Renewed account object\nclass Account : public RenewedAccountIntf\n{\n    string no;\n\npublic:\n    Account(string no) {\n        this->no = no;\n    }\n\n    void display()\n    {\n        cout << \"Display renewed account details \" << no << endl;\n    }\n};\n\n// Legacy account adapter to renewed interface\nclass LegacyAccountAdapter : public LegacyAccount,\n        public RenewedAccountIntf\n{\npublic:\n    LegacyAccountAdapter(string no) :\n        LegacyAccount(atoi(no.c_str()))\n    {\n    }\n\n    void display()\n    {\n        this->legacyAccountPrint();\n    }\n};\n\n\n// Test program\nint main()\n{\n    list<RenewedAccountIntf*> accountList;\n    accountList.push_back(new Account(\"accountholder 1\"));\n    accountList.push_back(new Account(\"accountholder 2\"));\n    accountList.push_back(new LegacyAccountAdapter(\"12345\"));\n\n    while ( ! accountList.empty() )\n    {\n        RenewedAccountIntf* obj = accountList.front();\n        obj->display();\n        accountList.pop_front();\n    }\n}"
  },
  {
    "name": "Bridge",
    "info": "The Bridge Pattern is used to separate out the interface from its implementation. Doing this gives the flexibility so that both can vary independently.",
    "content": "#include <iostream>\n\nusing namespace std;\n\n/* Implementor*/\nclass DrawingAPI {\n  public:\n   virtual void drawCircle(double x, double y, double radius) = 0;\n   virtual ~DrawingAPI() {}\n};\n\n/* Concrete ImplementorA*/\nclass DrawingAPI1 : public DrawingAPI {\n  public:\n   void drawCircle(double x, double y, double radius) {\n      cout << \"API1.circle at \" << x << ':' << y << ' ' << radius << endl;\n   }\n};\n\n/* Concrete ImplementorB*/\nclass DrawingAPI2 : public DrawingAPI {\npublic:\n   void drawCircle(double x, double y, double radius) {\n      cout << \"API2.circle at \" << x << ':' << y << ' ' <<  radius << endl;\n   }\n};\n\n/* Abstraction*/\nclass Shape {\n  public:\n   virtual ~Shape() {}\n   virtual void draw() = 0;\n   virtual void resizeByPercentage(double pct) = 0;\n};\n\n/* Refined Abstraction*/\nclass CircleShape : public Shape {\n  public:\n   CircleShape(double x, double y,double radius, DrawingAPI *drawingAPI) :\n       m_x(x), m_y(y), m_radius(radius), m_drawingAPI(drawingAPI)\n   {}\n   void draw() {\n      m_drawingAPI->drawCircle(m_x, m_y, m_radius);\n   }\n   void resizeByPercentage(double pct) {\n      m_radius *= pct;\n   }\n  private:\n   double m_x, m_y, m_radius;\n   DrawingAPI *m_drawingAPI;\n};\n\nint main(void) {\n   CircleShape circle1(1,2,3,new DrawingAPI1());\n   CircleShape circle2(5,7,11,new DrawingAPI2());\n   circle1.resizeByPercentage(2.5);\n   circle2.resizeByPercentage(2.5);\n   circle1.draw();\n   circle2.draw();\n   return 0;\n}"
  },
  {
    "name": "Composite",
    "info": "Composite lets clients treat individual objects and compositions of objects uniformly. The Composite pattern can represent both the conditions. In this pattern, one can develop tree structures for representing part-whole hierarchies.",
    "content": "#include <vector>\n#include <iostream> // std::cout\n#include <memory> // std::auto_ptr\n#include <algorithm> // std::for_each\nusing namespace std;\n \nclass Graphic\n{\npublic:\n  virtual void print() const = 0;\n  virtual ~Graphic() {}\n};\n \nclass Ellipse : public Graphic\n{\npublic:\n  void print() const {\n    cout << \"Ellipse \n\";\n  }\n};\n \nclass CompositeGraphic : public Graphic\n{\npublic:\n  void print() const {\n    for(Graphic * a: graphicList_) {\n      a->print();\n    }\n  }\n \n  void add(Graphic *aGraphic) {\n    graphicList_.push_back(aGraphic);\n  }\n \nprivate:\n  vector<Graphic*>  graphicList_;\n};\n \nint main()\n{\n  // Initialize four ellipses\n  const auto_ptr<Ellipse> ellipse1(new Ellipse());\n  const auto_ptr<Ellipse> ellipse2(new Ellipse());\n  const auto_ptr<Ellipse> ellipse3(new Ellipse());\n  const auto_ptr<Ellipse> ellipse4(new Ellipse());\n \n  // Initialize three composite graphics\n  const auto_ptr<CompositeGraphic> graphic(new CompositeGraphic());\n  const auto_ptr<CompositeGraphic> graphic1(new CompositeGraphic());\n  const auto_ptr<CompositeGraphic> graphic2(new CompositeGraphic());\n \n  // Composes the graphics\n  graphic1->add(ellipse1.get());\n  graphic1->add(ellipse2.get());\n  graphic1->add(ellipse3.get());\n \n  graphic2->add(ellipse4.get());\n \n  graphic->add(graphic1.get());\n  graphic->add(graphic2.get());\n \n  // Prints the complete graphic (four times the string \"Ellipse\")\n  graphic->print();\n  return 0;\n}"
  },
  {
    "name": "Decorator",
    "info": "Useful, when you want to add capabilities (statically or dynamically) to an object without sub-classing the concrete object's class as well as not affecting other objects of the same concrete class.",
    "content": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass actor {\npublic:\n    actor() {}\n    virtual void act() {}\n    virtual string name() {}\n};\n\nclass actorConcretePerson: public actor {\npublic:\n    actorConcretePerson(string name) { mName = name; }\n    void act() { cout << mName << \" is acting\" << endl;}\n    string name() { return mName; }\nprivate:\n    string mName;\n\n};\n\nclass actorCharacter: public actor {\npublic:\n    actorCharacter(string charName) { mCharName = charName; }\n    void setActorPerson( actor *anActor) {mActor = anActor;}\n    void act() { mActor->act(); }\n    actor* getActor() { return mActor; }\n    void actCharacter() { act(); cout << mCharName << \" is the role\" << endl;}\n    string getCharName() { return mCharName; }\nprivate:\n    actor *mActor;\n    string mCharName;\n};\n\nclass actorCharacterTheif: public actorCharacter {\npublic:\n    actorCharacterTheif(string charName):actorCharacter(charName) { }\n    void setTarget(string target) { mTarget = target ; }\n    void steal() { cout << getActor()->name() << \", the \" << getCharName() << \": Stole \" << mTarget << endl; }\n\nprivate:\n    string mTarget;\n\n};\n\nclass actorCharacterPolice: public actorCharacter {\npublic:\n    actorCharacterPolice(string charName):actorCharacter(charName) { }\n    void setTrack(string track) { mTrack = track ; }\n    void catchThief() { cout << getActor()->name() << \", the \" << getCharName() << \": Cought \" << mTrack << endl; }\nprivate:\n    string mTrack;\n};\n\n\nint main()\n{\n    actor *cage = new actorConcretePerson(\"NicolasCage\");\n    actor *travolta = new actorConcretePerson(\"JohnTravolta\");\n\n    actorCharacterPolice *police = new actorCharacterPolice(\"Commissioner\");\n    actorCharacterTheif *smuggler = new actorCharacterTheif(\"Smuggler\");\n    actorCharacterTheif *robber = new actorCharacterTheif(\"Robber\");\n\n    cout << \"Basic concrete objects and methods...\" << endl;\n    cage->act();\n    travolta->act();\n\n    cout << endl << \"Decorator objects and methods...\" << endl;\n    police->setActorPerson(travolta);\n    smuggler->setActorPerson(cage);\n\n    police->actCharacter();\n    police->setTrack(smuggler->getCharName());\n    police->catchThief();\n\n    smuggler->act();\n    smuggler->actCharacter();\n    smuggler->setTarget(\"Gold\");\n    smuggler->steal();\n\n    robber->setActorPerson(travolta);\n    robber->act();\n    robber->actCharacter();\n    robber->setTarget(\"Dollars\");\n    robber->steal();\n\n    return 0;\n}"
  },
  {
    "name": "Facade",
    "info": "Makes an existing complex software library easier to use by providing a simpler interface for common tasks.",
    "content": "#include <iostream>\nusing namespace std;\n\n// Transfer library\nclass Usb {\npublic:\n    bool isAvailable()\n    {\n        return false;\n    }\n\n    void connect()\n    {\n        cout << \"Connecting via USB\" << endl;\n    }\n\n    void send(string file)\n    {\n        cout << file << \" sent.\" << endl;\n    }\n};\n\nclass Bluetooth {\npublic:\n    bool isAvailable()\n    {\n        return true;\n    }\n\n    void connect()\n    {\n        cout << \"Connecting via BT\" << endl;\n    }\n\n    void authenticate()\n    {\n        cout << \"Authenticating BT\" << endl;\n    }\n\n    void send(string file)\n    {\n        cout << file << \" sent.\" << endl;\n    }\n};\n\n// The Facade\nclass FileTransfer {\npublic:\n    void sendFile(string fileName)\n    {\n        Usb* u = new Usb();\n        Bluetooth* b = new Bluetooth();\n        if ( u->isAvailable() )\n        {\n            u->connect();\n            u->send(fileName);\n        }\n        else if ( b->isAvailable() )\n        {\n            b->connect();\n            b->authenticate();\n            b->send(fileName);\n        }\n        else\n        {\n            cout << \"Not sent\" << endl;\n        }\n        delete b;\n        delete u;\n    }\n};\n\n// Test Program\nint main()\n{\n    FileTransfer* ft = new FileTransfer();\n    ft->sendFile(\"mypicture\");\n    delete ft;\n}"
  },
  {
    "name": "Proxy",
    "info": "The Proxy Pattern will provide an object a surrogate or placeholder for another object to control access to it. It is used when you need to represent a complex object with a simpler one. If creation of an object is expensive, it can be postponed until the very need arises and meanwhile a simpler object can serve as a placeholder. This placeholder object is called the “Proxy” for the complex object.",
    "content": "#include <iostream>\n\nusing namespace std; \n\nclass Subject \n{\npublic:\n    virtual void request() = 0;\n    virtual ~Subject() {}\n};\n \nclass RealSubject : public Subject \n{\npublic:\n    void request() { \n        cout << \"RealSubject.request()\" << endl; \n    }\n};\n \nclass Proxy : public Subject \n{\nprivate:\n    Subject* realSubject;\npublic:\n    Proxy() : realSubject (new RealSubject()) \n    {}\n    ~Proxy() { \n        delete realSubject; \n    }\n    // Forward calls to the RealSubject:\n    void request() { \n        realSubject->request(); \n    }\n};\n \nint main() {\n    Proxy p;\n    p.request();\n}"
  },
  {
    "name": "Chain of Reponsibility",
    "info": "The basic idea behind this pattern is that a request or a command passes through a chain of objects until it is handled.",
    "content": "#include <iostream>\nusing namespace std;\n\n// STATES\nenum ErrorStates { ANALYZE=0, FIX, VERIFY, CLOSE };\n\n// Command Class\nclass ErrorReport {\n\n  private:  \n    ErrorStates state;\n      \n  public:\n    ErrorReport(ErrorStates state) {\n        this->state = state;\n    }\n    ErrorStates GetState() {\n        return state;\n    }\n    void SetState(ErrorStates state) {\n        this->state = state;\n    }\n};\n\n// General base class for all processing objects\nclass Error {\n\n  protected:\n    ErrorStates state;\n    Error* successor;\n      \n  public:\n    Error(ErrorStates aState) { state = aState; }\n\n    void SetSuccessor  (Error* error) {\n        this->successor = error;\n    }\n\n    virtual void ProcessError(ErrorReport& report) = 0;\n};\n\n// Processing object class 1 for state ANALYZE\nclass AnalyzeError : public Error {\n\n   public:\n     AnalyzeError() : Error(ANALYZE) {};\n\n     void ProcessError(ErrorReport& report) {\n       if ( report.GetState() == ANALYZE ) {\n           cout << \"AnalyzeError::Handled the command to analyze the error ...\" << endl;\n       }\n       else {\n           cout << \"AnalyzeError::Passing to my successor ...\" << endl;\n           successor->ProcessError(report);\n       }\n   }\n};\n\n// Processing object class 2 for state  FIX\nclass FixError : public Error {\n\n  public:\n    FixError() : Error(FIX) {};\n\n    void ProcessError(ErrorReport& report) {\n        if ( report.GetState() == FIX ) {\n             cout << \"FixError::Handled the command to fix the error ...\" << endl;\n        }\n        else {\n             cout << \"FixError::Passing to my successor ...\" << endl;\n             successor->ProcessError(report);\n        }\n    }\n};\n\n// Processing object class 3 for state VERIFY\nclass VerifyError : public Error {\n\n  public:\n    VerifyError() : Error(VERIFY) {};\n\n    void ProcessError(ErrorReport& report) {\n        if ( report.GetState() == VERIFY ) {\n            cout << \"VerifyError::Handled the command to verify the error ...\" << endl;\n        }\n        else {\n            cout << \"VerifyError::Passing to my successor ...\" << endl;\n            successor->ProcessError(report);\n        }\n    }\n};\n\n// Processing object class 4 for state CLOSE\nclass CloseError : public Error {\n\n  public:\n    CloseError() : Error(CLOSE) {};\n\n    void ProcessError(ErrorReport& report) {\n        if ( report.GetState() == CLOSE ) {\n            cout << \"CloseError::Handled the command to close the error ...\" << endl;\n        }\n        else {\n            cout << \"VerifyError::No successor ... ignore\" << endl;\n            cout << \"No action required ...\" << endl;\n        }\n    }\n};\n\n\nint main()\n{\n    // Create instances for processing objects\n    AnalyzeError* analyzeError = new AnalyzeError();\n    FixError* fixError = new FixError();\n    VerifyError* verifyError = new VerifyError();\n    CloseError* closeError = new CloseError();\n\n    // Create the chain of responsibility\n    analyzeError->SetSuccessor(fixError);\n    fixError->SetSuccessor(verifyError);\n    verifyError->SetSuccessor(closeError);\n\n    // Issue command 1\n    cout << \"--------------- o/p for command 1 ----------------\" << endl;\n    ErrorReport* errorReport1 = new ErrorReport(ANALYZE);\n    analyzeError->ProcessError(*errorReport1);\n\n    // Issue command 2\n    cout << \"--------------- o/p for command 2 ----------------\" << endl;\n    ErrorReport* errorReport2 = new ErrorReport(CLOSE);\n    analyzeError->ProcessError(*errorReport2);\n\n    // Cleanup\n    delete errorReport2;\n    delete errorReport1;\n    delete closeError;\n    delete verifyError;\n    delete fixError;\n    delete analyzeError;\n}"
  },
  {
    "name": "Iterator",
    "info": "The basic idea of the iterator is that it permits the traversal of a container (like a pointer moving across an array). ",
    "content": "//Linked List Class\nclass IteratorCannotMoveToNext{}; // Error class\n class MyIntLList\n {\n public:\n     // The Node class represents a single element in the linked list. \n     // The node has a next node and a previous node, so that the user \n     // may move from one position to the next, or step back a single \n     // position. Notice that the traversal of a linked list is O(N), \n     // as is searching, since the list is not ordered.\n     class Node\n     {\n     public:\n         Node():mNextNode(0),mPrevNode(0),mValue(0){}\n         Node *mNextNode;\n         Node *mPrevNode;\n         int mValue;\n     };\n     MyIntLList():mSize(0) \n     {}\n     ~MyIntLList()\n     {\n         while(!Empty())\n             pop_front();\n     } // See expansion for further implementation;\n     int Size() const {return mSize;}\n     // Add this value to the end of the list\n     void push_back(int value)\n     {\n         Node *newNode = new Node;\n         newNode->mValue = value;\n         newNode->mPrevNode = mTail;\n         mTail->mNextNode = newNode;\n         mTail = newNode;\n         ++mSize;\n     }\n     // Remove the value from the beginning of the list\n     void pop_front()\n     {\n         if(Empty())\n             return;\n         Node *tmpnode = mHead;\n         mHead = mHead->mNextNode;\n         delete tmpnode;\n         --mSize;\n     }\n     bool Empty()\n     {return mSize == 0;}\n \n     // This is where the iterator definition will go, \n     // but lets finish the definition of the list, first\n \n private:\n     Node *mHead;\n     Node *mTail;\n     int mSize;\n };\n\n //Iterator Class\n   /*\n      *  The iterator class knows the internals of the linked list, so that it \n      *  may move from one element to the next. In this implementation, I have \n      *  chosen the classic traversal method of overloading the increment \n      *  operators. More thorough implementations of a bi-directional linked \n      *  list would include decrement operators so that the iterator may move \n      *  in the opposite direction.\n      */\n     class Iterator\n     {\n     public:\n         Iterator(Node *position):mCurrNode(position){}\n         // Prefix increment\n         const Iterator &operator++()\n         {\n             if(mCurrNode == 0 || mCurrNode->mNextNode == 0)\n                 throw IteratorCannotMoveToNext();e\n             mCurrNode = mCurrNode->mNextNode;\n             return *this;\n         }\n         // Postfix increment\n         Iterator operator++(int)\n         {\n             Iterator tempItr = *this;\n             ++(*this);\n             return tempItr;\n         }\n         // Dereferencing operator returns the current node, which should then \n         // be dereferenced for the int. TODO: Check syntax for overloading \n         // dereferencing operator\n         Node * operator*()\n         {return mCurrNode;}\n         // TODO: implement arrow operator and clean up example usage following\n     private:\n         Node *mCurrNode;\n     };\n     // The following two functions make it possible to create \n     // iterators for an instance of this class.\n     // First position for iterators should be the first element in the container.\n     Iterator Begin(){return Iterator(mHead);}\n     // Final position for iterators should be one past the last element in the container.\n     Iterator End(){return Iterator(0);}\n\n//Main Entry point\nint main(){\n    // Create a list\n     MyIntLList myList;\n     // Add some items to the list\n     for(int i = 0; i < 10; ++i)\n         myList.push_back(i);\n     // Move through the list, adding 42 to each item.\n     for(MyIntLList::Iterator it = myList.Begin(); it != myList.End(); ++it)\n         (*it)->mValue += 42;\n}"
  },
  {
    "name": "Mediator",
    "info": "Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.",
    "content": "#include <iostream>\n#include <string>\n#include <list>\n\nclass MediatorInterface;\n\nclass ColleagueInterface {\n        std::string name;\n    public:\n        ColleagueInterface (const std::string& newName) : name (newName) {}\n        std::string getName() const {return name;}\n        virtual void sendMessage (const MediatorInterface&, const std::string&) const = 0;\n        virtual void receiveMessage (const ColleagueInterface*, const std::string&) const = 0;\n};\n\nclass Colleague : public ColleagueInterface {\n    public:\n        using ColleagueInterface::ColleagueInterface;\n        virtual void sendMessage (const MediatorInterface&, const std::string&) const override;\n    private:\n        virtual void receiveMessage (const ColleagueInterface*, const std::string&) const override;\n};\n\nclass MediatorInterface {\n    private:\n        std::list<ColleagueInterface*> colleagueList;\n    public:\n        const std::list<ColleagueInterface*>& getColleagueList() const {return colleagueList;}\n        virtual void distributeMessage (const ColleagueInterface*, const std::string&) const = 0;\n        virtual void registerColleague (ColleagueInterface* colleague) {colleagueList.emplace_back (colleague);}\n};\n\nclass Mediator : public MediatorInterface {\n    virtual void distributeMessage (const ColleagueInterface*, const std::string&) const override;\n};\n\nvoid Colleague::sendMessage (const MediatorInterface& mediator, const std::string& message) const {\n    mediator.distributeMessage (this, message);\n}\n\nvoid Colleague::receiveMessage (const ColleagueInterface* sender, const std::string& message) const {\n     std::cout << getName() << \" received the message from \" << sender->getName() << \": \" << message << std::endl;            \n}\n\nvoid Mediator::distributeMessage (const ColleagueInterface* sender, const std::string& message) const {\n    for (const ColleagueInterface* x : getColleagueList())\n        if (x != sender)  // Do not send the message back to the sender\n            x->receiveMessage (sender, message);\n}\n \nint main() {\n    Colleague *bob = new Colleague (\"Bob\"),  *sam = new Colleague (\"Sam\"),  *frank = new Colleague (\"Frank\"),  *tom = new Colleague (\"Tom\");\n    Colleague* staff[] = {bob, sam, frank, tom};\n    Mediator mediatorStaff, mediatorSamsBuddies;\n    for (Colleague* x : staff)\n        mediatorStaff.registerColleague(x);\n    bob->sendMessage (mediatorStaff, \"I'm quitting this job!\");\n    mediatorSamsBuddies.registerColleague (frank);  mediatorSamsBuddies.registerColleague (tom);  // Sam's buddies only\n    sam->sendMessage (mediatorSamsBuddies, \"Hooray!  He's gone!  Let's go for a drink, guys!\");    \n    return 0;\n}"
  },
  {
    "name": "Memento",
    "info": "Without violating encapsulation the Memento Pattern will capture and externalize an object’s internal state so that the object can be restored to this state later.",
    "content": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nconst std::string NAME = \"Object\";\n\ntemplate <typename T>\nstd::string toString (const T& t) {\n    std::stringstream ss;\n    ss << t;\n    return ss.str();\n}\n\nclass Memento;\n\nclass Object {\n      private:\n            int value;\n            std::string name;\n            double decimal;  // and suppose there are loads of other data members\n      public:\n        Object (int newValue): value (newValue), name (NAME + toString (value)), decimal ((float)value / 100) {}\n        void doubleValue() {value = 2 * value;  name = NAME + toString (value);  decimal = (float)value / 100;}\n        void increaseByOne() {value++;  name = NAME + toString (value);  decimal = (float)value / 100;}\n        int getValue() const {return value;}\n        std::string getName() const {return name;}\n        double getDecimal() const {return decimal;}\n        Memento* createMemento() const;\n        void reinstateMemento (Memento* mem);\n};\n\nclass Memento {\n      private:\n         Object object;\n      public:\n            Memento (const Object& obj):  object (obj) {}\n            Object snapshot() const {return object;}  // want a snapshot of Object itself because of its many data members\n};\n\nMemento* Object::createMemento() const {\n    return new Memento (*this);\n}\n\nvoid Object::reinstateMemento (Memento* mem) {\n    *this = mem->snapshot();\n}\n\nclass Command {\n      private:\n        typedef void (Object::*Action)();\n        Object* receiver;\n        Action action;\n        static std::vector<Command*> commandList;\n        static std::vector<Memento*> mementoList;\n        static int numCommands;\n        static int maxCommands;\n      public:\n        Command (Object *newReceiver, Action newAction): receiver (newReceiver), action (newAction) {}\n        virtual void execute() {\n            if (mementoList.size() < numCommands + 1)\n                mementoList.resize (numCommands + 1);\n            mementoList[numCommands] = receiver->createMemento();  // saves the last value\n            if (commandList.size() < numCommands + 1)\n                commandList.resize (numCommands + 1);\n            commandList[numCommands] = this;  // saves the last command\n            if (numCommands > maxCommands)\n                  maxCommands = numCommands;\n            numCommands++;\n            (receiver->*action)();\n        }\n        static void undo() {\n            if (numCommands == 0)\n            {\n                std::cout << \"There is nothing to undo at this point.\" << std::endl;\n                return;\n            }\n            commandList[numCommands - 1]->receiver->reinstateMemento (mementoList[numCommands - 1]);\n            numCommands--;\n        }\n        void static redo() {\n            if (numCommands > maxCommands)\n            {\n                std::cout << \"There is nothing to redo at this point.\" << std::endl;\n                return ;\n            }\n            Command* commandRedo = commandList[numCommands];\n            (commandRedo->receiver->*(commandRedo->action))();\n            numCommands++;\n        }\n};\n\nstd::vector<Command*> Command::commandList;\nstd::vector<Memento*> Command::mementoList;\nint Command::numCommands = 0;\nint Command::maxCommands = 0;\n\nint main()\n{\n    int i;\n    std::cout << \"Please enter an integer: \";\n    std::cin >> i;\n    Object *object = new Object(i);\n    \n    Command *commands[3];\n    commands[1] = new Command(object, &Object::doubleValue);\n    commands[2] = new Command(object, &Object::increaseByOne);\n    \n    std::cout << \"0.Exit,  1.Double,  2.Increase by one,  3.Undo,  4.Redo: \";\n    std::cin >> i;\n    \n    while (i != 0)\n    {\n        if (i == 3)\n              Command::undo();\n        else if (i == 4)\n              Command::redo();\n        else if (i > 0 && i <= 2)\n              commands[i]->execute();\n        else\n        {\n            std::cout << \"Enter a proper choice: \";\n            std::cin >> i;\n            continue;\n        }\n        std::cout << \"   \" << object->getValue() << \"  \" << object->getName() << \"  \" << object->getDecimal() << std::endl;\n        std::cout << \"0.Exit,  1.Double,  2.Increase by one,  3.Undo,  4.Redo: \";\n        std::cin >> i;\n    }\n}"
  },
  {
    "name": "Strategy",
    "info": "Defines a family of algorithms, encapsulates each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients who use it.",
    "content": "#include <iostream>\nusing namespace std;\n\nclass StrategyInterface\n{\n    public:\n        virtual void execute() const = 0;\n};\n\nclass ConcreteStrategyA: public StrategyInterface\n{\n    public:\n        void execute() const override\n        {\n            cout << \"Called ConcreteStrategyA execute method\" << endl;\n        }\n};\n\nclass ConcreteStrategyB: public StrategyInterface\n{\n    public:\n        void execute() const override\n        {\n            cout << \"Called ConcreteStrategyB execute method\" << endl;\n        }\n};\n\nclass ConcreteStrategyC: public StrategyInterface\n{\n    public:\n        void execute() const override\n        {\n            cout << \"Called ConcreteStrategyC execute method\" << endl;\n        }\n};\n\nclass Context\n{\n    private:\n        StrategyInterface * strategy_;\n\n    public:\n        explicit Context(StrategyInterface *strategy):strategy_(strategy)\n        {\n        }\n\n        void set_strategy(StrategyInterface *strategy)\n        {\n            strategy_ = strategy;\n        }\n\n        void execute() const\n        {\n            strategy_->execute();\n        }\n};\n\nint main(int argc, char *argv[])\n{\n    ConcreteStrategyA concreteStrategyA;\n    ConcreteStrategyB concreteStrategyB;\n    ConcreteStrategyC concreteStrategyC;\n\n    Context contextA(&concreteStrategyA);\n    Context contextB(&concreteStrategyB);\n    Context contextC(&concreteStrategyC);\n\n    contextA.execute(); // output: \"Called ConcreteStrategyA execute method\"\n    contextB.execute(); // output: \"Called ConcreteStrategyB execute method\"\n    contextC.execute(); // output: \"Called ConcreteStrategyC execute method\"\n    \n    contextA.set_strategy(&concreteStrategyB);\n    contextA.execute(); // output: \"Called ConcreteStrategyB execute method\"\n    contextA.set_strategy(&concreteStrategyC);\n    contextA.execute(); // output: \"Called ConcreteStrategyC execute method\"\n\n    return 0;\n}"
  },
  {
    "name": "Template Method",
    "info": "In the template pattern, parts of program which are well defined like an algorithm are defined as a concrete method in the base class. The specifics of implementation are left to the derived classes by making these methods as abstract in the base class.",
    "content": "//Has nothing to do with c++ templates\n\n#include <iostream>\nusing namespace std;\n\n// Base class\n// Template class\nclass Account {\n    public:\n        // Abstract Methods\n        virtual void Start() = 0;\n\n        virtual void Allow() = 0;\n\n        virtual void End() = 0;\n\n        virtual int MaxLimit() = 0;\n\n        // Template Method\n        void Withdraw(int amount) {\n\n            Start();\n\n            int limit = MaxLimit();\n            if ( amount < limit ) {\n            Allow();\n            }\n            else {\n            cout << \"Not allowed\" << endl;\n            }\n\n            End();\n        }\n};\n\n// Derived class\nclass AccountNormal : public Account {\n    public:\n        void Start() {\n            cout << \"Start ...\" << endl;\n        }\n\n        void Allow() {\n            cout << \"Allow ...\" << endl;\n        }\n\n        void End() {\n            cout << \"End ...\" << endl;\n        }\n\n        int MaxLimit() {\n            return 1000;\n        }\n};\n\n// Derived class\nclass AccountPower : public Account {\n    public:\n        void Start() {\n            cout << \"Start ...\" << endl;\n        }\n\n        void Allow() {\n            cout << \"Allow ...\" << endl;\n        }\n\n        void End() {\n            cout << \"End ...\" << endl;\n        }\n\n        int MaxLimit() {\n            return 5000;\n        }\n};\n\nint main() {\n    AccountPower power;\n    power.Withdraw(1500);\n\n    AccountNormal normal;\n    normal.Withdraw(1500);\n}"
  },
  {
    "name": "Visitor",
    "info": "Visitor pattern allows to separate the data structures and the algorithms to be applied on the data.",
    "content": "#include <iostream>\n#include <list>\nusing namespace std;\n\n// Forwards\nclass VisitorIntf;\n\n// Abstract interface for Element objects\nclass ElementIntf\n{\npublic:\n    virtual string name() = 0;\n    virtual void accept(VisitorIntf* object) = 0;\n};\n\n// Abstract interface for Visitor objects\nclass VisitorIntf\n{\npublic:\n    virtual void visit(ElementIntf* object) = 0;\n};\n\n// Concrete element object\nclass ConcreteElement1 : public ElementIntf\n{\npublic:\n    string name()\n    {\n        return \"ConcreteElement1\";\n    }\n\n    void accept(VisitorIntf *object)\n    {\n        object->visit(this);\n    }\n};\n\n\n// Concrete element object\nclass ConcreteElement2 : public ElementIntf\n{\npublic:\n    string name()\n    {\n        return \"ConcreteElement2\";\n    }\n\n    void accept(VisitorIntf *object)\n    {\n        object->visit(this);\n    }\n};\n\n// Visitor logic 1\nclass ConcreteVisitor1 : public VisitorIntf\n{\npublic:\n    void visit(ElementIntf *object)\n    {\n        cout << \"Visited \" << object->name() <<\n                \" using ConcreteVisitor1.\" << endl;\n    }\n};\n\n// Visitor logic 2\nclass ConcreteVisitor2 : public VisitorIntf\n{\npublic:\n    void visit(ElementIntf *object)\n    {\n        cout << \"Visited \" << object->name() <<\n             \" using ConcreteVisitor2.\" << endl;\n    }\n};\n\n//  Test main program\nint main()\n{\n    list<ElementIntf*> elementList1;\n    elementList1.push_back(new ConcreteElement1());\n    elementList1.push_back(new ConcreteElement2());\n\n    VisitorIntf* visitor1 = new ConcreteVisitor1();\n    while ( ! elementList1.empty() )\n    {\n        ElementIntf* element = elementList1.front();\n        element->accept(visitor1);\n        elementList1.pop_front();\n    }\n\n    list<ElementIntf*> elementList2;\n    elementList2.push_back(new ConcreteElement1());\n    elementList2.push_back(new ConcreteElement2());\n    VisitorIntf* visitor2 = new ConcreteVisitor2();\n    while ( ! elementList2.empty() )\n    {\n        ElementIntf* element = elementList2.front();\n        element->accept(visitor2);\n        elementList2.pop_front();\n    }\n\n    delete visitor1;\n    delete visitor2;\n}"
  }
]